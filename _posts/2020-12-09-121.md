---
title: "자료구조와 자료형 파트 정리"
date: 2020-12-09
categories: JS DataType
---

- 원시값의 메서드

  - 원시값에 메서드나 프로퍼티 접근 시 **원시 래퍼 객체** 만들어짐

  - 원시 래퍼 객체는 새로운 원시값 반환 후 바로 삭제

  - 바로 삭제되는 이유는 최적화 때문

  - 원시값 생성자는 원시값이 아닌 **객체**가 반환됨

- 숫자형

  - JS 는 숫자를 나타내는 64비트 형식의 숫자, 64비트를 넘을 시 BigInt 제공

  - 64 비트중 52비트는 숫자, 11비트는 소수점 위치, 1비트는 부호로 저장됨

  - Math 로 다양한 수학 연산 가능

  - 1비트의 부호로 인해 모든 숫자에 부호 설정 가능(+0, -0)

  - 정밀도 손상이란 2진수 기반의 메모리 저장에 의해 숫자에 변형이 일어나 정밀도가 낮아지는 것을 말함

  - 10진수 기반의 수가 2의 거듭제곱이 아닌 값으로 나눌 시 무한소수가 되고 반올림으로 해결하는 과정에서 정확하게 숫자가 저장되지 않음

- 문자열

  - UTF-16 형식을 따르며 비교의 기준이 됨

  - 따옴표의 종류로 구분되며 작은/큰 따옴표, 백틱으로 나뉨

  - 백틱은 작은/큰따옴표와 나눠지며 다른 기능 제공

  - 이터러블 자료형

  - 불변성을 띄고 있어서 중간 글자 하나를 바꿀 수 없음

  - 역 슬레시로 특수문자 표시 가능

- 배열

  - 순서와 관련된 메서드 가진 **객체**

  - 요소의 자료형엔 제약 없음

  - 선언은 new 연산자와 배열 리터럴 연산자로 가능(리터럴이 다루기 좋음)

  - 큐/스택 구조 구현 가능

  - 객체처럼 다룰 시 배열의 특성 잃어버림() for of 지향, 프로퍼티 추가 지양)

  - 내부를 편집할 때 index도 조작되므로 큐보다 스택이 성능에 유리

  - 메서드

    - 분류는 기존 배열 수정, 새로운 배열 반환, 배열 탐색, 배열 변형, 배열 여부 판단 등으로 나뉨

- 이터러블 객체

  - 배열을 일반화 한 객체

  - 적용된 객체는 for..of 문법 적용해서 순회 가능

  - [Symbol.iterator](특수 내장 심볼)

    - 객체에 추가 시 이터러블화

    - 반드시 next 메서드가 있는 객체인 **이터레이터** 반환해야 함

    - 명시적으로 호출해서 반복 대상인 객체와 분리 가능

    - next는 {done: Boolean, value: any} 값 반환

  - **for..of 알고리즘**

    1. 시작될 시 for..of 는 [Symbol.iterator] 호출

    2. [Symbol.iterator] 유/무에 따라 실행/에러

    3. 반환된 이터레이터 만을 대상으로 동작

    4. 다음 값 필요해질 시 next() 메서드 호출

    5. next 반환 값에서 done의 값이 true 가 될 댸 까지 value 값 갱신

  - 유사 배열

    - 숫자 인덱스와 length 프로퍼티가 있는 객체

    - 이터레이터가 구현되어 있지 않고 대부분 객체도 아니라서 for..of 와 배열 메서드 사용 불가능

  - Array.from 으로 이터러블이나 유사 배열을 진짜 배열로 만들 수 있음

- 맵과 셋

  - 객체, 배열의 자료 구조 부족에 의한 탄생

  - 맵

    - 키-값 쌍의 자료 구조로 객체와 유사하지만 키에 다양한 자료구조 가능

    - 키를 문자열로 변환하지 않고 그대로 유지

    - 키 비교시 sameValueZero 라는 알고리즘 사용

    - 다양한 메서드, 프로퍼티 존재

  - 셋

    - 중복을 허용하지 않는 값을 모아놓은 특별한 컬렉션

    - 다양한 메서드, 프로퍼티 존재

  - 맵, 셋의 공통점

    - 이터러블 객체

    - 메서드를 공유해서 상호 호환성을 어느정도 보장

    - 이터러블 작업 시 컬렉션에 요소나 값을 추가한 순서대로 수행

    - 컬렉션 내 요소나 값 재정렬하거나 숫자 이용해 특정 요소나 값 가지고오기 불가능

- 위크맵과 위크셋

  - JS 의 복합 자료 구조의 요소는 참조값 없어져도 가비지 컬렉터가 건들지 않기에 해당 요소가 메모리에서 유지되기 떄문에 최적화에 유용하지 않음

  - 가비지 컬렉터로 최적화 하기 위해 등장

  - 저장된 객체가 참조값이 없어질 경우 해당 객체는 가비지 컬렉터에 의해 메모리에서 삭제됨

  - '추가 데이터'(캐싱) 저장하는 용도로 유용

  - 가비지 컬렉션을 언제 하는지 정확히 알 수 없기 떄문에 반복 작업 불가능

  - 위크맵

    - 맵과 유사하지만 요소의 키는 오직 객체만 가능

  - 위크셋

    - 셋과 유사하지만 요소는 객체만 저장 가능

- Object.keys, values, entries

  - key, values, entires 메서드

    - 포괄적인 용도로 만들어졌기 때문에 합의 준수해야 함

    - Map, Set, Array 에만 적용 가능

  - Object.keys, values, entries

    - 자료구조 전체가 객체에 기반하기 때문에 커스텀 메서드와 내장 메서드 둘 다 지원하기 위해 만들어짐

    - 일반 객체에서 사용 가능하며 인자에 객체 들어가고 배열 반환함

    - 객체를 변환하여 배열 전용 메서드 사용할 때 유용

- 구조 분해 할당

  - 객체나 배열을 변수로 분해할 때 사용

  - 분해 대상을 수정하거나 파괴하지 않음

  - 할당 연산자 우측엔 모든 이터러블 올 수 있으며 좌측엔 '할당할 수 있는 것' 이라면 뭐든 올 수 있음

  - 기본값 설정 가능

  - 연산자 좌측의 패턴과 우측의 패턴을 같게 하여 중첩된 구조도 분해 가능

- Date 객체

  - 날짜/시간 관련된 기능 있음

  - 월, 요일은 0으로 시작함

  - 범위를 넘어가는 구성요소 설정 시 Date 자동 고침됨

  - 타임 스탬프는 1970년 첫날 기준으로 흘러간 밀리초 나타내는 정수이며 Date가 숫자형으로 형 변환 시 반환됨

  - new 연산자로 생성

  - 다양한 메서드 존재 (문자열에서 날짜 읽는 메서드 등)

- JSON과 메서드

  - 값이나 객체를 나타내주는 독자적인 표준을 가진 데이터 형식

  - 일반 객체, 배열, 문자열, 숫자, 불린값, null 지원

  - 함수, 심볼형, undefined 인 프로퍼티는 무시됨

  - 순환 참조의 경우 stringify 불가능

  - stringify 로 원하는 값 JSON 으로 직렬화, parse 로 JSON을 본래값으로 역 직렬화 할 수 있으며 함수(replacer)를 인수로 넘겨줄 시 원하는 값만 읽거나 쓰기 가능

  - stringify 는 객체에 toJSON 메서드 있을 시 자동으로 호출해줌
