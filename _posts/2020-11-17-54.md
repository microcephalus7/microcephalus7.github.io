---
title: "call/apply와 데코레이터, 포워딩"
date: 2020-11-17
categories: JS
---

# call/apply와 데코레이터, 포워딩

- 데코레이터는 함수를 감싸는 래퍼를 반환해서 함수의 행동을 변화. 주요 작업은 여전히 함수에서 처리

- 데코레이터는 함수에 추가된 '가능' 혹 '상' 정도.

- 데코레이터는 재사용 가능하며 원래 함수와 분리되기 때문에 원래 함수 복잡성 증가하지 않으며 여러 데코레이터 함수 조합해서 가능하다는 이점 있음

- 데코레이터는 코드 변경 없이 캐싱 기능 추가할 때나 그와 비슷한 상황에서 흔히 사용

- call, apply는 함수의 특별 내장 메서드로 컨텍스트 설정 가능

- func.call(context, arg1, arg2) 는 주어진 컨텍스트(this에 conteext가 할당)와 인수 사용해 func 호출

- func.apply(context, args) 는 주어진 컨텍스트(this에 conteext가 할당)와 유사 배열 args 가 인수로 전달되어 func 호출

- func.call(context, ...arguments) 로 전개 연산자 사용해 이터러블 처리 가능

- JS 엔진에서는 apply 를 최적화하기 때문에 call 보다 apply 사용하는게 조금 더 빠름

- 콜 포워딩은 인수 전체를 다른 함수에 전달하는 것을 말하며 func.apply(context, args) 와 func.apply(context, ...arguments) 로 가능

- 콜 포워딩으로 여러 인수 받아서 map 을 이ㅛㅇ할 때 복수 키를 지원하는 맵과 유사한 자료 구조 구현하거나 중첩 맵 사용이나 여러 값을 합치는 해싱 함수 통해 구현 가능

- 메서드 빌리기는 특정 객체에서 메서드 가져오고 다른 객체를 컨텍스트로 고장한 후 함수를 호출하는 형태로 가능

- 메서드 빌리기는 배열 메서드 빌려서 이를 arguments(유사 배열이나 이터러블 객체) 에 적용할 때 흔히 사용
