---
title: "트랜잭션(transaction)과 ACID 특성을 보장하는 방법"
date: 2021-01-05
categories: DB
---

# 트랜잭션

질의(query)를 하나의 묶음 처리하고 질의가 중단 될 경우 처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행 마치면 commit을 하는 실행 단위를 의미
즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업 수행의 논리적 방식
Not all Nothing

작업 수행의 논리적 단위라고도 하며 DBMS 성능은 초당 트렌잭션의 실행 수로 측정함

- 사용 이유

  DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단 될 수 있는 등의 데이터 부정합을 방지하고자 할 때 사용

  병렬로 처리할 수 밖에 없는 현실적인 상황에서 부정합을 방지하기 위해 사용

  데이터를 병렬로 처리하지 않으면 한 번에 하나의 프로세스만 처리하면 되지만 너무 느림

- 스캐쥴 관리

  트랜잭션에서 중요한 것

  스케쥴 잘 못 짜게 되면 데드락에 빠지게 됨

- 특성

  앞 글자만 따서 ACID 특성이라 함

  - 원자성 (Atomicity)

    All or Nothing의 개념으로 작업 단위를 일부분만 실행하지 않는 다는 것을 의미

  - 일관성 (Consistency)

    트랜잭션이 성공적으로 완료되면 일관적인 DB 상태, 즉 데이터 타입의 일관성을 유지하는 것을 의미

  - 격리성 (Isolation)

    트랜잭션 끼리 서로 간섭할 수 없음

  - 지속성 (Duraability)

    성공적으로 수행된 트랜잭션(commit)은 영원히 반영됨

- 특성 보장

  - 원자성 보장

    현재 수항하고 있는 트랜잭션에서 오류 발생 시 현재 내역을 날리고 임시 영역에 저장했던 상태로 rollback

    현재 수행하고 있는 트랜잭션에 의해 새롭게 변경되는 내역이 DB 테이블

    - 롤백 세그먼트

      이전 데이터들이 임시로 저장되는 영역

      트랜잭션의 원자성이 보장되는 이유

      - save point

        확실히 보장해 줄 수 있는 구간을 지정할 때 사용

        트랜잭션이 길어질 수록 rollback 도 길어지는 것을 방지하기 위해 사용

        rollback은 save point 이전은 확실하다고 간주하고 그 이후부터 진행

  - 일관성 보장

    트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건 (기본키, 외래키, 도메인, 도메인 제약조건 등)을 만족함으로써 보장

    - 트리거

      어떤 이벤트와 조건이 발생했을 때 이용해 보장함

      DB 시스템이 자동적으로 수행할 똥작을 명시하는데 사용(어떤 행위의 시작을 알리는 것)

      create : 트리거를 생성하는 코드

      after : 트리거가 실행되기 위한 event

  - 고립성 보장

    고립성 보장 방법에 이해하기 위해서는 병행 트랜잭션을 알아야 함

    - 병형 처리

      CPU가 여러 프로세스를 처리하는 것 처럼, 트랜잭션에 정해진 시간을 할당해서 작업을 하다가 부여된 시간이 끝나면 다른 트랜잭션을 실행하는 방식으로 트랜잭션을 조금씩 처리하는 것

      트랜잭션 간섭이 일어날 수 있음

    - 고립성 보장

      lock & excute unlock을 통해 고립성 보장

      - lock & excute unlock

        데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록 고립성 보장

        수행 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용

        - shared_lock

          데이터 쓰기는 허용하지 않고 오직 읽기만 허용

        - exclusive_lock

          데이터 쓸 때 다른 트랜잭션이 읽을 수도 쓸 수도 없도록 하는 exclusive_lock 사용

          읽기, 쓰기 작업 끝나면 unlock을 통해 다른 트랜잭션이 lock할 수 있도록 데이터에 대한 잠금 풀어줌

        - 데드락 (deadlock)

          lock & unlock을 잘 못 사용할 시 일어남

          모든 트랜잭션이 아무것도 수행할 수 없는 상태

    - 2PL 프로토콜

      여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하기 위한 목적을 가진 프로토콜

      lock(상승 단계), unlock(하강 단계)가 번갈아 수행(섞이지)하지 않고 lock이 쭉 수행된 후에 unlock이 쭉 수행되어야 한다는 프로토콜

      병행처리에서 트랜잭션의 고립성 모장

      데드락 걸리는 것을 방지 하기 위해 규칙을 통해 고립성을 보장

      - 2가지 단계의 locking

        - growing phase (상승 단계)

          read_lock, write_lock 을 의미

        - shrinking phase (하강 단계)

          unlock 을 의미

      - locking을 하는 방법

        - 보수적 locking (consevative locking)

          트랜잭션이 시작되면 모든 lock을 얻는 방식

          데드락이 발생하지 않지만 병생성이 좋지 못 함

        - 엄격한 locking (strict locking)

          트랜잭션이 commit 을 만날 때 까지 lock을 갖고 있다가 commit을 만날 때 unlock 하는 방식

          데드락이 발생하지만 병행성이 좋아서 일반적으로 사용

> 출처 : https://victorydntmd.tistory.com/129?category=687930
