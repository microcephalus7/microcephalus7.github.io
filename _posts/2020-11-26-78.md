---
title: "'try..catch'와 에러 핸들링"
date: 2020-11-26
categories: JS class
---

- 에러 발생 시 스크립트는 '죽고(즉시 중단)' 콘솔에 에러 출력

- try..catch 이용시 스크립트 죽는 걸 방지하며, **런타임 에러**(실행 가능한 코드) 처리 가능 (실행 불가능한 코드는 엔진이 코드 이해할 수 없기 때문에 코드 복구 불가능하며 try..catch 동작 안 함)

- try 블록에선 코드 실행, 에러 발생 시 catch에서 잡아내고 코드 블록 실행

- try..catch 알고리즘은 try{} 블록의 코드 실행되고 error만날 시 try 코드 중단 후 catch 블록 코드 로 제어흐름 넘어감

- trh..catch 는 동기적으로 동작하기 떄문에 비동기 함수에서 실행하고 싶을 시 비동기 함수의 코드 블록 내부에서 실행해야 함

- finally 로 try/catch 이후 에러 발생 여부 상관 없이 코드 블록 실행

- finally 는 try/catch 에서 값이 바깥 코드로 반환되기 전에 실행됨.

- 에러 객체는 message(에러 메세지), name(에러 이름을 담은 문자열로 에러 생성자 이름), stack(표준은 아니지만 대부분 호스트 환경이 지원하는 프로퍼티로 에러 발생한 순간의 스택 나타냄) 프로퍼티 존재

- 에러 객체 필요없을 시 catch(err) {} 대신 catch {} 사용

- try에러 발생 시 throw로 에러 객체 반환하며 catch 블록에 이 객체를 인수로 코드블록에 전달

- throw 연산자로 에러 직접 만들 수 있음.

- try 에서 에러 예상 후 throw 로 에러 생성해서 던져서 catch 절에서 해당 에러 사용 가능

- 이론상으론 throw 인수에 모든 것 넘길 수 있지만 대개 내장 Error 클래스 상속받은 여러 객체 인수에 넘김

- 다시 던지기는 에러 처리 시 사용되는 중요한 패턴으로 catch 블록에서 예상했거나 알고 있는 에러 다루고 예상치 못한 에러는 catch에서 throw로 외부로 다시 던짐(rethrow)

- 함수는 return 이나 throw 만날 시 종료됨

- try, catch, finally 안의 변수는 해당 코드 블록의 지역변수

- try..catch 없이도 대부분 호스트 환경이 '전역' 에러 핸들러 지원하기 때문에 '떨어져 나온' 에러 잡을 수 있음

- try..finally 로 catch 절이 없는 상황 실행 가능하며 try에서 발생한 에러는 항상 밖으로 떨어져 나오며 finally는 실행 흐름이 함수 떠나기 전에 실행됨

- 전역 catch는 스크립트 죽었을 때 잡아내는 기능

- window.onerror 는 브라우저 환경의 전역 에러 핸들러 프로퍼티로 프로퍼티에 함수 할당해 에러 처리 가능

- 에러 로깅 관련 서비스로 에러 발생 시 에러 내용 담아서 네트워크 요청 받아 에러 확인 가능
